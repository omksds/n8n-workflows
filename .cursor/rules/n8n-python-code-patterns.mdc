---
globs: *.json,*.py
description: n8n Python Code ãƒãƒ¼ãƒ‰ã§ã®å‹å®‰å…¨æ€§ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
---

# n8n Python Code ãƒãƒ¼ãƒ‰é–‹ç™ºãƒ‘ã‚¿ãƒ¼ãƒ³

## ğŸ Python Code ãƒãƒ¼ãƒ‰è¨­å®š

### å¿…é ˆè¨­å®š

```json
{
  "parameters": {
    "mode": "runOnceForEachItem", // å„ã‚¢ã‚¤ãƒ†ãƒ ã«å¯¾ã—ã¦å®Ÿè¡Œ
    "language": "python"
  }
}
```

### ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³

```python
# æ­£ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆrunOnceForEachItem ãƒ¢ãƒ¼ãƒ‰ï¼‰
bucket_name = _json.get('bucket_name', 'unknown')
file_key = _json.get('file_key', 'unknown')

# ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹
if _binary and 'image_data' in _binary:
    binary_data = _binary['image_data']
```

## ğŸ”¢ å‹å¤‰æ›ã¨å®‰å…¨æ€§

### å¿…é ˆã®å‹å¤‰æ›ãƒ‘ã‚¿ãƒ¼ãƒ³

```python
# n8n Switch ãƒãƒ¼ãƒ‰ã¨ã®æ•´åˆæ€§ã®ãŸã‚æ˜ç¤ºçš„ã«å‹å¤‰æ›
image_data = {
    'width': int(width),                    # æ•´æ•°
    'height': int(height),                  # æ•´æ•°
    'aspectRatio': float(aspect_ratio),     # æµ®å‹•å°æ•°ç‚¹
    'is_tall': bool(aspect_ratio < 0.67),   # ãƒ–ãƒ¼ãƒ«å€¤ï¼ˆSwitchç”¨ï¼‰
    'classification': str(classification),  # æ–‡å­—åˆ—
    'decimal_ratio': round(aspect_ratio, 3) # ä¸¸ã‚å‡¦ç†
}
```

### ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®š

```python
# å¿…ãšæœ‰åŠ¹ãªå€¤ã‚’ä¿è¨¼ï¼ˆSwitch ãƒãƒ¼ãƒ‰æ•´åˆæ€§ã®ãŸã‚ï¼‰
if not width or not height or width <= 0 or height <= 0:
    width, height = 1024, 768  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤
    detection_method = 'fallback'

# ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”è¨ˆç®—ï¼ˆå¿…ãšæ•°å€¤ã‚’ä¿è¨¼ï¼‰
aspect_ratio = float(width / height)
```

## ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå‡¦ç†

### n8n S3 ãƒãƒ¼ãƒ‰å¯¾å¿œ

```python
def parse_file_size(size_str):
    """
    n8n S3 ãƒãƒ¼ãƒ‰ãŒè¿”ã™ '1.06 MB' å½¢å¼ã‚’æ•°å€¤ï¼ˆãƒã‚¤ãƒˆï¼‰ã«å¤‰æ›

    Args:
        size_str: ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆ'1.06 MB', 1048576, ãªã©ï¼‰

    Returns:
        int: ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆï¼‰
    """
    if isinstance(size_str, (int, float)):
        return int(size_str)

    if not isinstance(size_str, str):
        return 0

    # '1.06 MB' ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‚’æ•°å€¤ã«å¤‰æ›
    size_match = re.search(r'([\d.]+)\s*(MB|KB|B)', size_str, re.IGNORECASE)
    if size_match:
        size_value = float(size_match.group(1))
        size_unit = size_match.group(2).upper()
        if size_unit == 'MB':
            return int(size_value * 1024 * 1024)
        elif size_unit == 'KB':
            return int(size_value * 1024)
        else:  # B
            return int(size_value)

    # æ•°å€¤ã®ã¿ã®å ´åˆ
    try:
        return int(float(size_str))
    except (ValueError, TypeError):
        return 0

# ä½¿ç”¨ä¾‹
raw_file_size = binary_data.get('fileSize', 0)
file_size_bytes = parse_file_size(raw_file_size)
```

## ğŸš¨ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### å …ç‰¢ãªã‚¨ãƒ©ãƒ¼å‡¦ç†

```python
try:
    # ãƒ¡ã‚¤ãƒ³å‡¦ç†
    aspect_ratio = width / height
    classification = 'tall' if aspect_ratio < 0.67 else 'not_tall'

    image_data = {
        'aspectRatio': float(aspect_ratio),
        'is_tall': bool(aspect_ratio < 0.67),
        'classification': str(classification)
    }

except Exception as error:
    print(f"[ERROR] Analysis Error: {str(error)}")
    import traceback
    traceback.print_exc()

    # ã‚¨ãƒ©ãƒ¼æ™‚ã§ã‚‚ Switch ãƒãƒ¼ãƒ‰é€šéå¯èƒ½ãªå½¢å¼
    image_data = {
        'aspectRatio': 1.33,        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        'is_tall': False,           # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ–ãƒ¼ãƒ«å€¤
        'classification': 'error',
        'error': f'Analysis Error: {str(error)}',
        'error_type': type(error).__name__
    }
```

## ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³

### è©³ç´°ãªãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

```python
# å‡¦ç†é–‹å§‹æ™‚
print(f"[DEBUG] Processing: bucket={bucket_name}, file_key={file_key}")
print(f"[DEBUG] Input JSON keys: {list(_json.keys())}")
print(f"[DEBUG] Binary available: {bool(_binary)}")

# è¨ˆç®—çµæœ
print(f"[DEBUG] Final results:")
print(f"[DEBUG] - Width: {width} (type: {type(width)})")
print(f"[DEBUG] - Height: {height} (type: {type(height)})")
print(f"[DEBUG] - Aspect Ratio: {aspect_ratio} (type: {type(aspect_ratio)})")
print(f"[DEBUG] - is_tall: {is_tall} (type: {type(is_tall)})")
print(f"[DEBUG] - Classification: {classification}")

# Switch ãƒãƒ¼ãƒ‰ç”¨ãƒ‡ãƒ¼ã‚¿ç¢ºèª
print(f"[DEBUG] Switchç”¨ãƒ‡ãƒ¼ã‚¿: aspectRatio={image_data['aspectRatio']}, is_tall={image_data['is_tall']}")
```

## ğŸ“¤ æˆ»ã‚Šå€¤ã®å½¢å¼

### æ¨™æº–çš„ãªæˆ»ã‚Šå€¤ãƒ‘ã‚¿ãƒ¼ãƒ³

```python
# runOnceForEachItem ãƒ¢ãƒ¼ãƒ‰ã§ã®æˆ»ã‚Šå€¤
result = {
    'json': {
        **_json,  # å…ƒã®å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
        'image_analysis': image_data  # åˆ†æçµæœã‚’è¿½åŠ 
    },
    'binary': _binary  # ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
}

return result
```

## ğŸ¯ Switch ãƒãƒ¼ãƒ‰é€£æº

### Switch ãƒãƒ¼ãƒ‰ç”¨ãƒ‡ãƒ¼ã‚¿æº–å‚™

```python
# Switch ãƒãƒ¼ãƒ‰ã§ä½¿ã„ã‚„ã™ã„å½¢å¼
image_data = {
    # æ•°å€¤è¨ˆç®—çµæœ
    'aspectRatio': float(aspect_ratio),
    'decimal_ratio': round(aspect_ratio, 3),

    # Switchç”¨ãƒ–ãƒ¼ãƒ«å€¤ï¼ˆæ¨å¥¨ï¼‰
    'is_tall': bool(aspect_ratio < 0.67),
    'is_wide': bool(aspect_ratio >= 1.2),
    'is_square': bool(0.8 <= aspect_ratio < 1.2),

    # æ–‡å­—åˆ—åˆ†é¡
    'classification': str(classification),

    # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    'debug_info': {
        'threshold_comparison': f"{aspect_ratio} < 0.67 = {aspect_ratio < 0.67}",
        'switch_ready': True
    }
}
```
